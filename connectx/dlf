package mnkgame;

import java.util.Random;

public class dlf implements MNKPlayer {

    public MNKCellState myPlayer, myOpponent;
    private MNKBoard B;
    private MNKGameState myWin, yourWin;
    private int TIMEOUT, bestMoveRow, bestMoveCol, bestVal, moveVal;
    MNKCellState [][] board;
    private Random rand;
    private long start;
    private static final int max = 1, min = -1;
    private int playerScore = 0, opponentScore = 0;





    //CONSTRUCTOR
    public dlf() {

    }



    @Override
    public void initPlayer(int M, int N, int K, boolean first, int timeout_in_secs) {

        myWin   = first ? MNKGameState.WINP1 : MNKGameState.WINP2;
        yourWin = first ? MNKGameState.WINP2 : MNKGameState.WINP1;
        rand    = new Random(System.currentTimeMillis());
        bestMoveCol = -1;
        bestMoveRow = -1;
        bestVal = -1000;
        TIMEOUT = timeout_in_secs;

        //new board of cellstate
        B = new MNKBoard(M, N, K);
        board = new MNKCellState[M][N];
        for(int i=0; i<B.M; i++){
            for(int j=0; j<B.N; j++){
                board[i][j] = MNKCellState.FREE;
            }
        }

    }





    // This will return the best possible
    // move for the player
    @Override
    public MNKCell selectCell(MNKCell[] FC, MNKCell[] MC) {

        start = System.currentTimeMillis();
        myPlayer   = (MC.length % 2 == 0) ? MNKCellState.P1 : MNKCellState.P2;
        myOpponent   = (MC.length % 2 == 1) ? MNKCellState.P2 : MNKCellState.P1;



        // PRIMA MOSSA CASUALE
        if(MC.length == 0) {

            MNKCell c1 = FC[rand.nextInt(FC.length)];
            board[c1.i][c1.j] = myPlayer;
            B.markCell(c1.i,c1.j);
            return c1;
        }
        else {

            //Recover last move from myOpponent
            board[MC[MC.length - 1].i][MC[MC.length - 1].j] = myOpponent;
            MNKCell c = MC[MC.length - 1];
            B.markCell(c.i, c.j);

            // se Ã¨ rimasta una sola mossa
            if (FC.length == 1) return FC[0];

            // Single move win
            for (MNKCell d : FC) {
                if (B.markCell(d.i, d.j) == myWin) {
                    return d;
                } else {
                    B.unmarkCell();
                }
            }

            //Single move loss
            //MNKCell c1 = findBestMove(board, FC, MC);
            //System.out.println("c1 = "+ c1);
           /* for (MNKCell d : FC) {
                if (B.markCell(d.i, d.j) == yourWin) {
                    //B.unmarkCell(); // undo my move
                    //B.unmarkCell();
                    //B.markCell(d.i,d.j);
                    return d;
                } else {
                    B.unmarkCell();
                }
            }*/
        }
        return findBestMove(board, FC, start, MC);
    }





    // This function returns true if there are moves
    // remaining on the board. It returns false if
    // there are no moves left to play.
    public Boolean isMovesLeft(MNKCellState board[][]){
        for (int i = 0; i < B.M; i++)
            for (int j = 0; j < B.N; j++)
                if (board[i][j] == MNKCellState.FREE)
                    return true;
        return false;
    }





    // Traverse all cells, evaluate minimax function
    // for all empty cells. And return the cell
    // with optimal value.
    // This will return the best possible
    // move for the player
    public MNKCell findBestMove(MNKCellState board[][], MNKCell[] FC, long start, MNKCell[] MC) {

        int bestVal = -1000;
        MNKCell bestMove;

        for (MNKCell mnkCell : FC) {

            bestMove = mnkCell;
            board[bestMove.i][bestMove.j] = myPlayer;
            moveVal = minimax(board, 0, false, min, max, start);
            board[bestMove.i][bestMove.j] = MNKCellState.FREE;

            if (moveVal > bestVal) {
                bestMoveRow = bestMove.i;
                bestMoveCol = bestMove.j;
                bestVal = moveVal;
            }

            //timeout
            if ((System.currentTimeMillis() - start) / 1000.0 > TIMEOUT * (99.0 / 100.0)) {

                board[bestMoveRow][bestMoveCol] = myPlayer;
                B.markCell(bestMoveRow, bestMoveCol);
                return new MNKCell(bestMoveRow, bestMoveCol);
            }
        }

        for (MNKCell d : FC) {
            if (B.markCell(d.i, d.j) == yourWin) {

                B.unmarkCell();
                B.unmarkCell();
                B.markCell(d.i, d.j);
                return d;
            } else {
                B.unmarkCell();
            }
        }


        board[bestMoveRow][bestMoveCol] = myPlayer;
        B.markCell(bestMoveRow,bestMoveCol);

        return new MNKCell(bestMoveRow, bestMoveCol);
    }





    // This is the minimax function. It considers all
    // the possible ways the game can go and returns
    // the value of the board
    public int minimax(MNKCellState [][] board, int depth, Boolean isMax, int alpha, int beta, long start) {

        //eval function
        int score = evaluate(board);
        // If Maximizer has won the game
        // return his/her evaluated score
        if (score == 10) return score;
            // If Minimizer has won the game
            // return his/her evaluated score
        else if (score == -10) return score;
        // If there are no more moves and
        // no winner then it is a tie
        if (!isMovesLeft(board)) return 0;

        // If this maximizer's move
        if (isMax) {
            int eval = -1000; // -INFINITO
            // Traverse all cells
            for (int i = 0; i < B.M; i++) {
                for (int j = 0; j < B.N; j++) {
                    if (board[i][j] == MNKCellState.FREE) {
                        board[i][j] = myPlayer;
                        // Call minimax recursively and choose
                        // the maximum value
                        eval = Math.max(eval, minimax(board, depth + 1, !isMax, alpha, beta, start));
                        if(eval > alpha)
                            alpha = eval;
                        // CHECK ALPHABETA PRUNING
                        if (beta <= alpha)
                            return beta;
                        //break;
                        board[i][j] = MNKCellState.FREE;
                        //timeout
                        if ((System.currentTimeMillis() - start) / 1000.0 > TIMEOUT * (99.0 / 100.0)) break;
                    }
                }
            }
            return eval;
        }
        else {
            // If this minimizer>'s move
            int eval = 1000; // +INFINITO
            // Traverse all cells
            for (int i = 0; i < B.M; i++) {
                for (int j = 0; j < B.N; j++) {

                    if (board[i][j] == MNKCellState.FREE) {
                        board[i][j] = myOpponent;
                        // Call minimax recursively and choose
                        // the minimum value
                        eval = Math.min(eval, minimax(board, depth + 1, !isMax, alpha, beta, start));
                        if(eval < beta)
                            beta = eval;
                        // CHECK ALPHABETA PRUNING
                        if (beta <= alpha)
                            return beta;
                        //break;
                        board[i][j] = MNKCellState.FREE;
                        //timeout
                        if ((System.currentTimeMillis() - start) / 1000.0 > TIMEOUT * (99.0 / 100.0)) break;
                    }
                }
            }
            return eval;
        }
    }




    //a function that calculates the value of
    // the board depending on the placement of
    // pieces on the board.
    public int evaluate(MNKCellState board[][]) {

        // Checking for Rows for X or O victory.
        for (int row = 0; row < B.M; row++){
            for(int col = 0; col < B.N; col++){

                if(board[row][col] == myPlayer) playerScore++;
                else playerScore = 0;

                if(playerScore == B.K) return +10;
            }
            for(int col = 0; col < B.N; col++){

                if(board[row][col] == myOpponent) opponentScore++;
                else opponentScore = 0;

                if(opponentScore == B.K) return -10;
            }
        }
        // Checking for Columns for X or O victory.
        for (int col = 0; col < B.N; col++){
            playerScore = 0;
            opponentScore = 0;

            for(int row = 0; row < B.M; row++){

                if(board[row][col] == myPlayer) playerScore++;
                else playerScore = 0;
                if(playerScore == B.K) return +10;
            }
            for(int row = 0; row < B.M; row++){

                if(board[row][col] == myOpponent) opponentScore++;
                else opponentScore = 0;
                if(opponentScore == B.K) return -10;
            }
        }

        // Checking for Diagonals for X or O victory.

        int count1;

        for (int row = 0; row < B.M; row++){
            for (int col = 0; col < B.N; col++){

                playerScore = 0;
                count1 = 0;

                while(count1+col < B.N && count1+row < B.M){

                    if (board[count1+row][count1+col] == myPlayer) playerScore++;
                    else playerScore = 0;

                    if(playerScore == B.K) return +10;

                    count1++;
                }
            }
            for (int col = 0; col < B.N; col++){

                opponentScore = 0;
                count1 = 0;

                while(count1+col < B.N && count1+row < B.M){

                    if (board[count1+row][count1+col] == myOpponent) opponentScore++;
                    else opponentScore = 0;

                    if(opponentScore == B.K) return -10;

                    count1++;
                }
            }
        }

        int playerScoreInv = 0, opponentScoreInv = 0, count2 = 0;

        // Checking for Diagonals for X or O victory.
        for (int row = 0; row < B.M; row++){
            for (int col = 0; col < B.N; col++){

                playerScoreInv = 0;
                count1 = B.N;
                count2 = 0;

                while(row + count2 < B.M && count1-col-1 > 0){

                    if (board[count2+row][count1-col-1] == myPlayer) playerScoreInv++;
                    else playerScoreInv = 0;

                    if(playerScoreInv == B.K) return +10;

                    count1--;
                    count2++;
                }
            }
            for (int col = 0; col < B.N; col++){

                opponentScoreInv = 0;
                count1 = B.N;
                count2 = 0;

                while(count2+row < B.M && count1-col-1 > 0){

                    if (board[row + count2][count1-col-1] == myOpponent) opponentScoreInv++;
                    else opponentScoreInv = 0;

                    if(opponentScoreInv == B.K) return -10;

                    count1--;
                    count2++;
                }
            }
        }
        return 0;
    }



    public String playerName() {

        return "DLF";
    }


}